"use client"

import type React from "react"
import { useState, useEffect } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card"
import { Textarea } from "@/components/ui/textarea"
import { Loader2, FileText, Sparkles, AlertCircle, CheckCircle, Download } from "lucide-react"
import { FlashcardViewer } from "@/components/flashcards/flashcard-viewer"
import { useFlashcards } from "@/hooks/flashcards/use-flashcards"
import { useHealthCheck } from "@/hooks/flashcards/use-health-check"
import { LoadingSpinner } from "@/components/flashcards/loading-spinner"
import FlashcardUniversalFormContainer from "./FlashcardUniversalFormContainer"
import FlashcardLoading from "./FlashcardLoading"
import { jsPDF } from 'jspdf';
import 'jspdf-autotable'; // This import registers the autotable plugin with jspdf
import html2canvas from 'html2canvas';

export function FlashcardGenerator({ onLoadingChange }: { onLoadingChange?: (isLoading: boolean) => void } = { onLoadingChange: undefined }) {
  const { flashcards, isLoading, error, generateFlashcards, clearFlashcards, clearError } = useFlashcards()
  const { isHealthy, isLoading: healthLoading, error: healthError, checkHealth } = useHealthCheck()
  const [flashcardLanguage, setFlashcardLanguage] = useState<string>('english')

  // Notify parent component about loading state changes
  useEffect(() => {
    onLoadingChange?.(isLoading)
  }, [isLoading, onLoadingChange])

  console.log("ðŸŽ® FlashcardGenerator render:", {
    flashcardsCount: flashcards.length,
    isLoading,
    error,
    hasFlashcards: flashcards.length > 0
  });

  const handleReset = () => {
    clearFlashcards()
    clearError()
    setFlashcardLanguage('english')
  }

  // Helper function to load Unicode font for jsPDF
  const loadUnicodeFont = async (doc: jsPDF, language: string): Promise<void> => {
    try {
      // For Chinese, use Noto Sans SC (Simplified Chinese)
      if (language === 'chinese') {
        // Load NotoSansSC font from CDN
        const fontUrl = 'https://fonts.gstatic.com/s/notosanssc/v36/k3kCo84MPvpLmixcA63oeAL7Iqp5I5NKbQ.woff2';
        const response = await fetch(fontUrl);
        if (response.ok) {
          const fontData = await response.arrayBuffer();
          // Note: For production, you may want to embed the font file locally
          // For now, we'll use a fallback approach
        }
      }
      // jsPDF default fonts don't support Unicode well, so we'll use a different approach
      // We'll use html2canvas or similar for better Unicode support, but for now,
      // we'll encode text properly and use splitTextToSize for word wrapping
    } catch (error) {
      console.warn('Font loading failed, using default:', error);
    }
  };

  // Helper function to check if text contains non-Latin characters
  const hasNonLatinCharacters = (text: string): boolean => {
    return /[^\x00-\x7F]/.test(text);
  };

  // Helper function to get appropriate locale for date formatting
  const getLocaleForLanguage = (language: string): string => {
    const localeMap: Record<string, string> = {
      'italian': 'it-IT',
      'english': 'en-US',
      'spanish': 'es-ES',
      'french': 'fr-FR',
      'german': 'de-DE',
      'portuguese': 'pt-PT',
      'dutch': 'nl-NL',
      'russian': 'ru-RU',
      'chinese': 'zh-CN',
    };
    return localeMap[language] || 'en-US';
  };

  // Helper function to get translations based on language
  const getTranslations = (language: string) => {
    const translations: Record<string, Record<string, string>> = {
      'italian': {
        title: 'Flashcard Generate da FastSchool AI',
        date: 'Data di generazione',
        flashcard: 'Flashcard',
        question: 'Domanda',
        answer: 'Risposta',
        page: 'Pagina',
        of: 'di',
      },
      'english': {
        title: 'Flashcards Generated by FastSchool AI',
        date: 'Generation Date',
        flashcard: 'Flashcard',
        question: 'Question',
        answer: 'Answer',
        page: 'Page',
        of: 'of',
      },
      'spanish': {
        title: 'Tarjetas Generadas por FastSchool AI',
        date: 'Fecha de GeneraciÃ³n',
        flashcard: 'Tarjeta',
        question: 'Pregunta',
        answer: 'Respuesta',
        page: 'PÃ¡gina',
        of: 'de',
      },
      'french': {
        title: 'Cartes GÃ©nÃ©rÃ©es par FastSchool AI',
        date: 'Date de GÃ©nÃ©ration',
        flashcard: 'Carte',
        question: 'Question',
        answer: 'RÃ©ponse',
        page: 'Page',
        of: 'de',
      },
      'german': {
        title: 'Karteikarten Erstellt von FastSchool AI',
        date: 'Erstellungsdatum',
        flashcard: 'Karteikarte',
        question: 'Frage',
        answer: 'Antwort',
        page: 'Seite',
        of: 'von',
      },
      'portuguese': {
        title: 'CartÃµes Gerados por FastSchool AI',
        date: 'Data de GeraÃ§Ã£o',
        flashcard: 'CartÃ£o',
        question: 'Pergunta',
        answer: 'Resposta',
        page: 'PÃ¡gina',
        of: 'de',
      },
      'dutch': {
        title: 'Flashcards Gegenereerd door FastSchool AI',
        date: 'Generatiedatum',
        flashcard: 'Flashcard',
        question: 'Vraag',
        answer: 'Antwoord',
        page: 'Pagina',
        of: 'van',
      },
      'russian': {
        title: 'ÐšÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¡Ð¾Ð·Ð´Ð°Ð½Ñ‹ FastSchool AI',
        date: 'Ð”Ð°Ñ‚Ð° Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ñ',
        flashcard: 'ÐšÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ°',
        question: 'Ð’Ð¾Ð¿Ñ€Ð¾Ñ',
        answer: 'ÐžÑ‚Ð²ÐµÑ‚',
        page: 'Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°',
        of: 'Ð¸Ð·',
      },
      'chinese': {
        title: 'FastSchool AI ç”Ÿæˆçš„æŠ½è®¤å¡',
        date: 'ç”Ÿæˆæ—¥æœŸ',
        flashcard: 'æŠ½è®¤å¡',
        question: 'é—®é¢˜',
        answer: 'ç­”æ¡ˆ',
        page: 'é¡µ',
        of: 'å…±',
      },
    };
    return translations[language] || translations['english'];
  };

  const handleDownloadPdf = async () => {
    if (flashcards.length === 0) {
      console.log("âŒ No flashcards to download.");
      return;
    }

    try {
      // Check if flashcards contain non-Latin characters
      const hasNonLatin = flashcards.some(card => 
        hasNonLatinCharacters(card.question) || hasNonLatinCharacters(card.answer)
      );

      const translations = getTranslations(flashcardLanguage);
      const locale = getLocaleForLanguage(flashcardLanguage);
      const date = new Date().toLocaleDateString(locale, {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
      });

      // For languages with non-Latin characters, use HTML rendering approach
      if (hasNonLatin || flashcardLanguage === 'chinese' || flashcardLanguage === 'russian') {
        // Load Google Fonts for better Unicode support if needed
        await loadGoogleFonts(flashcardLanguage, hasNonLatin);
        
        // Create a hidden container with HTML content for PDF generation
        const printContainer = document.createElement('div');
        printContainer.style.position = 'absolute';
        printContainer.style.left = '-9999px';
        printContainer.style.top = '0';
        printContainer.style.width = '210mm'; // A4 width
        printContainer.style.padding = '20mm';
        printContainer.style.backgroundColor = 'white';
        // Use a comprehensive font stack that supports all languages
        const fontStack = [
          'system-ui',
          '-apple-system',
          '"Segoe UI"',
          'Roboto',
          '"Noto Sans"',
          '"Noto Sans CJK SC"',
          '"Noto Sans CJK TC"',
          '"Noto Sans CJK KR"',
          '"Noto Sans JP"',
          '"Noto Sans SC"',
          '"Noto Sans TC"',
          '"Noto Sans KR"',
          '"Noto Sans"',
          '"Helvetica Neue"',
          'Helvetica',
          'Arial',
          'sans-serif'
        ].join(', ');
        printContainer.style.fontFamily = fontStack;
        printContainer.style.fontSize = '14px';
        printContainer.style.lineHeight = '1.6';
        printContainer.style.color = '#000';

        // Add title and date
        const header = document.createElement('div');
        header.style.textAlign = 'center';
        header.style.marginBottom = '30px';
        header.innerHTML = `
          <h1 style="font-size: 24px; margin: 0 0 10px 0; font-weight: bold;">${translations.title}</h1>
          <p style="font-size: 12px; color: #808080; margin: 0;">${translations.date}: ${date}</p>
        `;
        printContainer.appendChild(header);

        // Add flashcards
        flashcards.forEach((card, index) => {
          const cardDiv = document.createElement('div');
          cardDiv.style.marginBottom = '25px';
          cardDiv.style.border = '1px solid #e0e0e0';
          cardDiv.style.borderRadius = '4px';
          cardDiv.style.padding = '15px';
          cardDiv.style.pageBreakInside = 'avoid';
          cardDiv.innerHTML = `
            <div style="font-size: 14px; font-weight: bold; margin-bottom: 10px; color: #333;">
              ${translations.flashcard} ${index + 1}:
            </div>
            <table style="width: 100%; border-collapse: collapse;">
              <tr style="border-bottom: 1px solid #e0e0e0;">
                <td style="width: 80px; padding: 8px; font-weight: bold; vertical-align: top; border-right: 1px solid #e0e0e0;">
                  ${translations.question}:
                </td>
                <td style="padding: 8px; vertical-align: top; word-wrap: break-word;">
                  ${escapeHtml(card.question)}
                </td>
              </tr>
              <tr>
                <td style="width: 80px; padding: 8px; font-weight: bold; vertical-align: top; border-right: 1px solid #e0e0e0;">
                  ${translations.answer}:
                </td>
                <td style="padding: 8px; vertical-align: top; word-wrap: break-word;">
                  ${escapeHtml(card.answer)}
                </td>
              </tr>
            </table>
          `;
          printContainer.appendChild(cardDiv);
        });

        document.body.appendChild(printContainer);

        // Render to canvas using html2canvas
        const canvas = await html2canvas(printContainer, {
          scale: 2,
          useCORS: true,
          logging: false,
          backgroundColor: '#ffffff',
        });

        // Clean up
        document.body.removeChild(printContainer);

        // Create PDF from canvas
        const imgData = canvas.toDataURL('image/png');
        const pdfWidth = 210; // A4 width in mm
        const pdfHeight = (canvas.height * pdfWidth) / canvas.width;
        
        const doc = new jsPDF({
          orientation: pdfHeight > pdfWidth ? 'portrait' : 'landscape',
          unit: 'mm',
          format: 'a4',
        });

        // Calculate how many pages we need
        const pageHeight = doc.internal.pageSize.getHeight();
        const imgWidth = pdfWidth;
        const imgHeight = pdfHeight;
        let heightLeft = imgHeight;
        let position = 0;

        // Add first page
        doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
        heightLeft -= pageHeight;

        // Add additional pages if needed
        while (heightLeft > 0) {
          position = heightLeft - imgHeight;
          doc.addPage();
          doc.addImage(imgData, 'PNG', 0, position, imgWidth, imgHeight);
          heightLeft -= pageHeight;
        }

        // Add page numbers
        const pageCount = (doc.internal as any).getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(10);
          doc.setTextColor(128);
          const pageText = `${translations.page} ${i} ${translations.of} ${pageCount}`;
          // Try to add page numbers, but may not work well with image-based PDF
          try {
            doc.text(
              pageText,
              doc.internal.pageSize.getWidth() - 30,
              doc.internal.pageSize.getHeight() - 10,
              { align: 'right' }
            );
          } catch (e) {
            // Page number addition may fail with image-based PDF
            console.warn('Could not add page number:', e);
          }
        }

        doc.save('flashcards.pdf');
        console.log("âœ… PDF downloaded successfully with Unicode support!");
      } else {
        // For Latin characters, use the original text-based approach (faster and smaller file size)
        const doc = new jsPDF();
        let yPos = 20;

        // Title
        doc.setFontSize(18);
        const titleLines = doc.splitTextToSize(translations.title, 180);
        doc.text(titleLines, 105, yPos, { align: 'center' });
        yPos += titleLines.length * 7 + 5;

        // Date
        doc.setFontSize(10);
        doc.setTextColor(128, 128, 128);
        const dateText = `${translations.date}: ${date}`;
        const dateLines = doc.splitTextToSize(dateText, 180);
        doc.text(dateLines, 105, yPos, { align: 'center' });
        yPos += dateLines.length * 7 + 15;
        doc.setTextColor(0, 0, 0);

        flashcards.forEach((card, index) => {
          if (yPos > doc.internal.pageSize.height - 60) {
            doc.addPage();
            yPos = 20;
            doc.setFontSize(18);
            const titleLines = doc.splitTextToSize(translations.title, 180);
            doc.text(titleLines, 105, yPos, { align: 'center' });
            yPos += titleLines.length * 7 + 5;
            doc.setFontSize(10);
            doc.setTextColor(128, 128, 128);
            const dateLines = doc.splitTextToSize(dateText, 180);
            doc.text(dateLines, 105, yPos, { align: 'center' });
            yPos += dateLines.length * 7 + 15;
            doc.setTextColor(0, 0, 0);
          }

          doc.setFontSize(12);
          const flashcardLabel = `${translations.flashcard} ${index + 1}:`;
          doc.text(flashcardLabel, 20, yPos);
          yPos += 10;

          (doc as any).autoTable({
            startY: yPos,
            body: [
              [`${translations.question}:`, card.question],
              [`${translations.answer}:`, card.answer],
            ],
            theme: 'grid',
            styles: {
              fontSize: 10,
              cellPadding: 3,
              valign: 'top',
              lineColor: [200, 200, 200],
              lineWidth: 0.1,
              overflow: 'linebreak',
              cellWidth: 'wrap',
            },
            headStyles: {
              fillColor: [240, 240, 240],
              textColor: [0, 0, 0],
              fontStyle: 'bold',
            },
            columnStyles: {
              0: { cellWidth: 35, fontStyle: 'bold' },
              1: { cellWidth: 'auto' },
            },
            margin: { left: 20, right: 20 },
          });
          yPos = (doc as any).lastAutoTable.finalY + 10;
        });

        // Add page numbers
        const pageCount = (doc.internal as any).getNumberOfPages();
        for (let i = 1; i <= pageCount; i++) {
          doc.setPage(i);
          doc.setFontSize(10);
          doc.setTextColor(128);
          const pageText = `${translations.page} ${i} ${translations.of} ${pageCount}`;
          doc.text(
            pageText,
            (doc.internal as any).pageSize.width - 30,
            (doc.internal as any).pageSize.height - 10,
            { align: 'right' }
          );
        }

        doc.save('flashcards.pdf');
        console.log("âœ… PDF downloaded successfully!");
      }
    } catch (error) {
      console.error("âŒ Error generating PDF:", error);
      alert("Failed to generate PDF. Please try again.");
    }
  };

  // Helper function to escape HTML
  const escapeHtml = (text: string): string => {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  };

  // Helper function to load Google Fonts for better Unicode support
  const loadGoogleFonts = async (language: string, checkNonLatin: boolean): Promise<void> => {
    return new Promise((resolve) => {
      // Check if fonts are already loaded
      if (document.getElementById('google-fonts-loaded')) {
        resolve();
        return;
      }

      const fontsToLoad: string[] = [];
      
      if (language === 'chinese') {
        fontsToLoad.push('Noto+Sans+SC');
      } else if (language === 'russian') {
        fontsToLoad.push('Noto+Sans');
      } else if (checkNonLatin) {
        // Load fonts for any non-Latin characters
        fontsToLoad.push('Noto+Sans', 'Noto+Sans+SC', 'Noto+Sans+TC', 'Noto+Sans+KR', 'Noto+Sans+JP');
      }

      if (fontsToLoad.length === 0) {
        resolve();
        return;
      }

      const link = document.createElement('link');
      link.id = 'google-fonts-loaded';
      link.rel = 'stylesheet';
      link.href = `https://fonts.googleapis.com/css2?${fontsToLoad.map(f => `family=${f}:wght@400;700`).join('&')}&display=swap`;
      
      link.onload = () => {
        // Wait a bit for fonts to be fully loaded
        setTimeout(() => resolve(), 500);
      };
      link.onerror = () => {
        // Even if fonts fail to load, continue with system fonts
        resolve();
      };
      
      document.head.appendChild(link);
    });
  };

  return (
    <div>
      {isLoading ? (
          /* Loading State */
          <div className="flex flex-col items-center justify-center min-h-[400px]">
            <FlashcardLoading />
            <h1 className="text-4xl font-bold text-foreground mb-4 text-center mt-8">
              Generazione delle tue Flashcard
            </h1>
          </div>
        ) : flashcards.length === 0 ? (
          /* Input Interface */
          <div>
            {/* Universal Form */}
            <FlashcardUniversalFormContainer 
              generateFlashcards={async (text, count, language, gradeLevel) => {
                setFlashcardLanguage(language || 'english');
                await generateFlashcards(text, count, language, gradeLevel);
              }}
            />

            {error && (
              <Card className="border-red-500 bg-red-50 dark:bg-red-900/10 mt-4">
                <CardContent className="p-4">
                  <div className="flex items-start gap-3">
                    <AlertCircle className="h-5 w-5 text-red-600 dark:text-red-400 mt-0.5" />
                    <div className="flex-1">
                      <div className="text-base font-semibold text-red-600 dark:text-red-400">Errore</div>
                      <div className="text-sm text-red-600 dark:text-red-400 mt-1">
                        {error}
                      </div>
                    </div>
                  </div>
                </CardContent>
              </Card>
            )}
          </div>
        ) : (
          /* Flashcard Results */
          <div className="space-y-6">
            <div className="flex items-center justify-between">
              <div>
                <h1 className="text-3xl font-bold text-foreground">Le tue Flashcard</h1>
                <p className="text-muted-foreground">
                  Generate {flashcards.length} flashcard{flashcards.length !== 1 ? "s" : ""} dal tuo materiale
                </p>
              </div>
              <div className="flex gap-2">
                <Button
                  onClick={handleReset}
                  variant="outline"
                  className="border-border text-foreground hover:bg-accent bg-transparent"
                >
                  Crea Nuovo Set
                </Button>
                <Button
                  onClick={handleDownloadPdf}
                  variant="outline"
                  className="border-border text-foreground hover:bg-accent bg-transparent"
                >
                  <Download className="h-4 w-4 mr-2" />
                  Scarica PDF
                </Button>
              </div>
            </div>

            <FlashcardViewer flashcards={flashcards} />
          </div>
        )}
    </div>
  )
}
